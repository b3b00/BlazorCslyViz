@using System.IO.Compression
@using System.Text
@using SharpFileSystem.FileSystems
@inject IJSRuntime JSRuntime
@inject NavigationManager NavManager
@inject IBlazorDialogService dialogService
@inject IJSUnmarshalledRuntime JSUnmarshalledRuntime


<div>
    <strong>@Title</strong>

    <p class="title">Visualization for CSLY with Viz.js </p>


    <div>

        <select class="form-control d-flex" @onchange="SelectSample">
            @foreach (var template in GetSamples())
            {
            <option value=@template>@template</option>
            }
        </select>
        

        <label for="grammarFile" class="input-label">Importer un fichier grammaire</label>
        <InputFile id="grammarFile" OnChange="LoadGrammar"/>
        <label for="inputFile" class="input-label">Importer un fichier source</label>
        <InputFile id="inputFile" OnChange="LoadGrammar"/>
        <div class="input" style="display: flex; flex-direction: row">

            <div style="flex-grow:1">
                <textarea style="flex-grow: 1" id="grammarBox" maxlength="2000" spellcheck="false" @bind="grammar" />
            </div>

            <div style="flex-grow:1">
                <textarea style="flex-grow: 1" i d="inputBox" maxlength="2000" spellcheck="false" @bind="source" />
            </div>

        </div>
        <button id="submitButton" @onclick="Render">
            Render
        </button>
        <button id="submitButton" @onclick="Compile">
            Compile
        </button>
        <button id="submitButton" @onclick="Generate">
            Generate...
        </button>
        <button id="submitButton" @onclick="GetJson">
            Download JSON...
        </button>
        <button id="extractButton" @onclick="ExtractGrammar">
            Extract grammar...
        </button>
    </div>


    <div id="graph">
        <div id="output">
            <div id="error"></div>
        </div>
    </div>
</div>

@code {

    [Parameter] public string? Title { get; set; }

    string source = @"1 / 2 / 3 + 4 + 3.14";

    string grammar = @"
genericLexer ExprLexer;

[Int] I;
[Double] D;


[Sugar] PLUS : ""+"";
[Sugar] MINUS : ""-"";
[Sugar] TIMES : ""*"";
[Sugar] DIVIDE : ""/"";

[Sugar] LPAREN : ""("";
[Sugar] RPAREN : "")"";


parser ExprParser;


-> root:  ExprParser_expressions ;


       
[Right 10] PLUS;
[Left 10] MINUS;
[Right 50] TIMES;
[Left 50]DIVIDE;
[Prefix 100] MINUS;

[Operand] operand : [I|D];
[Operand] operand : LPAREN ExprParser_expressions RPAREN;

";

    private string dot;

    protected override async void OnInitialized()
    {
    }

    private async Task LoadGrammar(InputFileChangeEventArgs e)
    {
        var content =
            await new StreamReader(e.File.OpenReadStream()).ReadToEndAsync();
        grammar = content;
        StateHasChanged();
    }

    private async Task LoadSource(InputFileChangeEventArgs e)
    {
        var content =
            await new StreamReader(e.File.OpenReadStream()).ReadToEndAsync();
        source = content;
        StateHasChanged();
    }


    private async void GetJson()
    {
        var json = CslyProcessor.GetJson(grammar, source);
        if (json.IsOK)
        {
            string fileName = "source.json";
            string contentType = "text/json";

            // Check if the IJSRuntime is the WebAssembly implementation of the JSRuntime
            if (JSUnmarshalledRuntime is IJSUnmarshalledRuntime webAssemblyJSRuntime)
            {
                webAssemblyJSRuntime.InvokeUnmarshalled<string, string, byte[], bool>("BlazorDownloadFileFast", fileName, contentType, UTF8Encoding.UTF8.GetBytes(json.Result));
                return;
            }

            // Fall back to the slow method if not in WebAssembly
            await JSRuntime.InvokeVoidAsync("BlazorDownloadFile", fileName, contentType, UTF8Encoding.UTF8.GetBytes(json.Result));
        }
    }


    private async void ExtractGrammar()
    {
        bool isCentered = true;
        DialogSize size;
        DialogAnimation animation = DialogAnimation.SlideDown;

        var dialogResult = await dialogService.ShowComponentAsDialog<ExtractDialogResult>(new ComponentAsDialogOptions(typeof(ExtractDialog))
        {
            Animation = DialogAnimation.SlideDown,
            Size = DialogSize.Normal,
            Centered = true,
            Parameters = new()
        });
        if (dialogResult != null && dialogResult.Ok)
        {
            var extractedGrammar = CslyProcessor.ExtractGrammar(dialogResult.Parser, dialogResult.Lexer);
            if (extractedGrammar.IsOK && !string.IsNullOrEmpty(extractedGrammar.Result))
            {
                this.grammar = extractedGrammar.Result;
                StateHasChanged();
            }
        }
    }

    private async void Generate()
    {
        bool isCentered = true;
        DialogSize size;
        DialogAnimation animation = DialogAnimation.SlideDown;

        var dialogResult = await dialogService.ShowComponentAsDialog<GenerateDialogResult>(new ComponentAsDialogOptions(typeof(GenerateDialog))
        {
            Animation = DialogAnimation.SlideDown,
            Size = DialogSize.Normal,
            Centered = true,
            Parameters = new()
        });
        if (dialogResult != null && dialogResult.Ok)
        {
            Console.WriteLine($"Generate => ns:{dialogResult.NameSpace}, type:{dialogResult.OutputType}");
            var sources = CslyProcessor.GenerateParser(grammar, dialogResult.NameSpace, dialogResult.OutputType);
            if (sources.IsOK)
            {
                byte[] compressedBytes;
                using (var outStream = new MemoryStream())
                {
                    using (var archive = new ZipArchive(outStream, ZipArchiveMode.Create, true))
                    {
                        var fileInArchive = archive.CreateEntry(sources.Result.ParserName + ".cs", CompressionLevel.Fastest);
                        using (var entryStream = fileInArchive.Open())
                        {
                            using (var fileToCompressStream = new MemoryStream(Encoding.UTF8.GetBytes(sources.Result.Parser)))
                            {
                                fileToCompressStream.CopyTo(entryStream);
                            }
                        }

                        fileInArchive = archive.CreateEntry(sources.Result.LexerName + ".cs", CompressionLevel.Fastest);
                        using (var entryStream = fileInArchive.Open())
                        {
                            using (var fileToCompressStream = new MemoryStream(Encoding.UTF8.GetBytes(sources.Result.Lexer)))
                            {
                                fileToCompressStream.CopyTo(entryStream);
                            }
                        }

                        fileInArchive = archive.CreateEntry(sources.Result.ParserName + ".csproj", CompressionLevel.Fastest);
                        using (var entryStream = fileInArchive.Open())
                        {
                            using (var fileToCompressStream = new MemoryStream(Encoding.UTF8.GetBytes(sources.Result.Project)))
                            {
                                fileToCompressStream.CopyTo(entryStream);
                            }
                        }
                    }

                    compressedBytes = outStream.ToArray();
                }


                string fileName = "parser.zip";
                string contentType = "application/zip";

                // Check if the IJSRuntime is the WebAssembly implementation of the JSRuntime
                if (JSUnmarshalledRuntime is IJSUnmarshalledRuntime webAssemblyJSRuntime)
                {
                    webAssemblyJSRuntime.InvokeUnmarshalled<string, string, byte[], bool>("BlazorDownloadFileFast", fileName, contentType, compressedBytes);
                    return;
                }

                // Fall back to the slow method if not in WebAssembly
                await JSRuntime.InvokeVoidAsync("BlazorDownloadFile", fileName, contentType, compressedBytes);
            }
            else
            {
                foreach (var error in sources.Errors)
                {
                    Console.WriteLine(error);
                    await AppendError(error);
                }
            }
        }
        else
        {
            Console.WriteLine("do not generate");
        }
    }

    private async void Render()
    {
        var dotresult = CslyProcessor.GetDot(grammar, source);
        if (dotresult.IsOK)
        {
            dot = dotresult.Result;
            await VizRender(dot);
        }
        else
        {
            foreach (var error in dotresult.Errors)
            {
                AppendError(error);
            }
        }
    }
    
    private async void Compile()
    {
        var compileResult = CslyProcessor.Compile(grammar);
        if (compileResult.IsOK)
        {
            await AppendMessage("Model is OK");
        }
        else
        {
            foreach (var error in compileResult.Errors)
            {
                await AppendError(error);
            }
        }
    }

    public async Task VizRender(string graph)
    {
        await JSRuntime.InvokeAsync<string>("vizRender", graph);
    }

    public async Task AppendError(string errorMessage)
    {
        await JSRuntime.InvokeAsync<string>("appendError", errorMessage);
    }
    
    public async Task AppendMessage(string message)
    {
        await JSRuntime.InvokeAsync<string>("appendMessage", message);
    }

    


    private Dictionary<string, string> SamplesGrammars = new Dictionary<string, string>();
    
    private Dictionary<string, string> SamplesSources = new Dictionary<string, string>();

    private Dictionary<string, string> Samples = new Dictionary<string, string>()
    {
        { "Expressions", "expression.txt" },
        { "XML", "xml.txt" },
        { "JSON", "json.txt" },
        { "simple template", "template.txt" },
        { "While language", "while.txt" },
        { "indented While language", "indented-while.txt" },
    };
    public List<string> GetSamples()
    {
        return Samples.Keys.ToList();
    }

    public async Task<string> GetSampleGrammar(string sampleName)
    {
        string sampleGrammar = "";
        if (!SamplesGrammars.TryGetValue(sampleName, out sampleGrammar))
        {
            if (Samples.TryGetValue(sampleName, out string path ))
            {
                var fs = new EmbeddedResourceFileSystem(GetType().Assembly);
                sampleGrammar = fs.ReadAllText($"/samples/grammar/{path}");
                SamplesGrammars[sampleName] = sampleGrammar;
            }
        }

        return sampleGrammar;
    }
    
    public async Task<string> getSampleSource(string sampleName)
    {
        string sampleSource = "";
        if (!SamplesSources.TryGetValue(sampleName, out sampleSource))
        {
            
            if (Samples.TryGetValue(sampleName, out string path ))
            {
                var fs = new EmbeddedResourceFileSystem(GetType().Assembly);
                sampleSource = fs.ReadAllText($"/samples/source/{path}");
                SamplesSources[sampleName] = sampleSource;
            }
        }

        return sampleSource;
    }

    public async void SelectSample(ChangeEventArgs e)
    {
        this.grammar = await GetSampleGrammar(e.Value?.ToString() ?? "");
        this.source = await getSampleSource(e.Value?.ToString() ?? "");
        StateHasChanged();
    }

}
