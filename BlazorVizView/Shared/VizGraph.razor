@using System.IO.Compression
@using System.Text
@using SharpFileSystem.FileSystems
@inject IJSRuntime JSRuntime
@inject NavigationManager NavManager
@inject IBlazorDialogService dialogService
@inject IJSUnmarshalledRuntime JSUnmarshalledRuntime
@inject ICslyContext cslyContext;


<div>
    <strong>@Title</strong>

    <p class="title">Visualization for CSLY with Viz.js </p>


    <div>

        <select class="form-control d-flex" @onchange="SelectSample">
            @foreach (var template in cslyContext.GetSamples())
            {
            <option value=@template>@template</option>
            }
        </select>
        

        <label for="grammarFile" class="input-label">Importer un fichier grammaire</label>
        <InputFile id="grammarFile" OnChange="LoadGrammar"/>
        <label for="inputFile" class="input-label">Importer un fichier source</label>
        <InputFile id="inputFile" OnChange="LoadGrammar"/>
        <div class="input" style="display: flex; flex-direction: row">

            <div style="flex-grow:1">
                <textarea style="flex-grow: 1" id="grammarBox" maxlength="2000" spellcheck="false" @bind="cslyContext.Grammar" />
            </div>

            <div style="flex-grow:1">
                <textarea style="flex-grow: 1" i d="inputBox" maxlength="2000" spellcheck="false" @bind="cslyContext.Source" />
            </div>

        </div>
        <button id="submitButton" @onclick="Render" class="btn btn-primary">
            Render
        </button>
        <button id="submitButton" @onclick="Compile" class="btn btn-primary">
            Compile
        </button>
        <button id="submitButton" @onclick="Generate" class="btn btn-primary">
            Generate...
        </button>
        <button id="submitButton" @onclick="GetJson" class="btn btn-primary">
            Download JSON...
        </button>
        <button id="extractButton" @onclick="ExtractGrammar" class="btn btn-primary">
            Extract grammar...
        </button>
    </div>


    <div id="graph">
        <div id="output">
            <div id="error"></div>
        </div>
    </div>
</div>

@code {

    [Parameter] public string? Title { get; set; }

    

    private string dot;

    protected override async void OnInitialized()
    {
    }

    private async Task LoadGrammar(InputFileChangeEventArgs e)
    {
        var content =
            await new StreamReader(e.File.OpenReadStream()).ReadToEndAsync();
        cslyContext.Grammar = content;
        StateHasChanged();
    }

    private async Task LoadSource(InputFileChangeEventArgs e)
    {
        var content =
            await new StreamReader(e.File.OpenReadStream()).ReadToEndAsync();
        cslyContext.Source = content;
        StateHasChanged();
    }


    private async void GetJson()
    {
        var json = CslyProcessor.GetJson(cslyContext.Grammar, cslyContext.Source);
        if (json.IsOK)
        {
            string fileName = "source.json";
            string contentType = "text/json";

            // Check if the IJSRuntime is the WebAssembly implementation of the JSRuntime
            if (JSUnmarshalledRuntime is IJSUnmarshalledRuntime webAssemblyJSRuntime)
            {
                webAssemblyJSRuntime.InvokeUnmarshalled<string, string, byte[], bool>("BlazorDownloadFileFast", fileName, contentType, UTF8Encoding.UTF8.GetBytes(json.Result));
                return;
            }

            // Fall back to the slow method if not in WebAssembly
            await JSRuntime.InvokeVoidAsync("BlazorDownloadFile", fileName, contentType, UTF8Encoding.UTF8.GetBytes(json.Result));
        }
    }


    private async void ExtractGrammar()
    {
        bool isCentered = true;
        DialogSize size;
        DialogAnimation animation = DialogAnimation.SlideDown;

        var dialogResult = await dialogService.ShowComponentAsDialog<ExtractDialogResult>(new ComponentAsDialogOptions(typeof(ExtractDialog))
        {
            Animation = DialogAnimation.SlideDown,
            Size = DialogSize.Normal,
            Centered = true,
            Parameters = new()
        });
        if (dialogResult != null && dialogResult.Ok)
        {
            var extractedGrammar = CslyProcessor.ExtractGrammar(dialogResult.Parser, dialogResult.Lexer);
            if (extractedGrammar.IsOK && !string.IsNullOrEmpty(extractedGrammar.Result))
            {
                cslyContext.Grammar = extractedGrammar.Result;
                StateHasChanged();
            }
        }
    }

    private async void Generate()
    {
        bool isCentered = true;
        DialogSize size;
        DialogAnimation animation = DialogAnimation.SlideDown;

        var dialogResult = await dialogService.ShowComponentAsDialog<GenerateDialogResult>(new ComponentAsDialogOptions(typeof(GenerateDialog))
        {
            Animation = DialogAnimation.SlideDown,
            Size = DialogSize.Normal,
            Centered = true,
            Parameters = new()
        });
        if (dialogResult != null && dialogResult.Ok)
        {
            Console.WriteLine($"Generate => ns:{dialogResult.NameSpace}, type:{dialogResult.OutputType}");
            var sources = CslyProcessor.GenerateParser(cslyContext.Grammar, dialogResult.NameSpace, dialogResult.OutputType);
            if (sources.IsOK)
            {
                byte[] compressedBytes;
                using (var outStream = new MemoryStream())
                {
                    using (var archive = new ZipArchive(outStream, ZipArchiveMode.Create, true))
                    {
                        var fileInArchive = archive.CreateEntry(sources.Result.ParserName + ".cs", CompressionLevel.Fastest);
                        using (var entryStream = fileInArchive.Open())
                        {
                            using (var fileToCompressStream = new MemoryStream(Encoding.UTF8.GetBytes(sources.Result.Parser)))
                            {
                                fileToCompressStream.CopyTo(entryStream);
                            }
                        }

                        fileInArchive = archive.CreateEntry(sources.Result.LexerName + ".cs", CompressionLevel.Fastest);
                        using (var entryStream = fileInArchive.Open())
                        {
                            using (var fileToCompressStream = new MemoryStream(Encoding.UTF8.GetBytes(sources.Result.Lexer)))
                            {
                                fileToCompressStream.CopyTo(entryStream);
                            }
                        }

                        fileInArchive = archive.CreateEntry(sources.Result.ParserName + ".csproj", CompressionLevel.Fastest);
                        using (var entryStream = fileInArchive.Open())
                        {
                            using (var fileToCompressStream = new MemoryStream(Encoding.UTF8.GetBytes(sources.Result.Project)))
                            {
                                fileToCompressStream.CopyTo(entryStream);
                            }
                        }
                    }

                    compressedBytes = outStream.ToArray();
                }


                string fileName = "parser.zip";
                string contentType = "application/zip";

                // Check if the IJSRuntime is the WebAssembly implementation of the JSRuntime
                if (JSUnmarshalledRuntime is IJSUnmarshalledRuntime webAssemblyJSRuntime)
                {
                    webAssemblyJSRuntime.InvokeUnmarshalled<string, string, byte[], bool>("BlazorDownloadFileFast", fileName, contentType, compressedBytes);
                    return;
                }

                // Fall back to the slow method if not in WebAssembly
                await JSRuntime.InvokeVoidAsync("BlazorDownloadFile", fileName, contentType, compressedBytes);
            }
            else
            {
                foreach (var error in sources.Errors)
                {
                    Console.WriteLine(error);
                    await AppendError(error);
                }
            }
        }
        else
        {
            Console.WriteLine("do not generate");
        }
    }

    private async void Render()
    {
;
        
        var dotresult = CslyProcessor.GetDot(cslyContext.Grammar, cslyContext.Source);
        if (dotresult.IsOK)
        {
            dot = dotresult.Result;
            await VizRender(dot);
        }
        else
        {
            foreach (var error in dotresult.Errors)
            {
                AppendError(error);
            }
        }
    }
    
    private async void Compile()
    {
        var compileResult = CslyProcessor.Compile(cslyContext.Grammar);
        if (compileResult.IsOK)
        {
            await AppendMessage("Model is OK");
        }
        else
        {
            foreach (var error in compileResult.Errors)
            {
                await AppendError(error);
            }
        }
    }

    public async Task VizRender(string graph)
    {
        await JSRuntime.InvokeAsync<string>("vizRender", graph);
    }

    public async Task AppendError(string errorMessage)
    {
        await JSRuntime.InvokeAsync<string>("appendError", errorMessage);
    }
    
    public async Task AppendMessage(string message)
    {
        await JSRuntime.InvokeAsync<string>("appendMessage", message);
    }

    

    
    
    

    public async void SelectSample(ChangeEventArgs e)
    {
        cslyContext.SetSample(e.Value?.ToString() ?? "");
        StateHasChanged();
    }

}
